---
title: 消息投递
description: 发后即忘（Tell）与请求-响应（Ask/Future）两种投递方式及用法。
---

本文介绍两种基础投递方式：**Tell**（发后即忘，含 TellSelf）与 **Ask**（请求-响应，配合 Reply 与 Future）。进阶能力见文末相关专题。

<Mermaid diagram={`flowchart LR
  A[发送方] -->|ctx.Tell| B[目标邮箱]
  B --> C[目标 OnReceive]
`} title="Tell（发后即忘）" />

<Mermaid diagram={`flowchart LR
  A[发送方] -->|ctx.Ask| B[目标邮箱]
  B --> C[目标 OnReceive]
  C -->|ctx.Reply| D[Future.Result]
  D --> A
`} title="Ask（请求-响应）" />

## Tell / TellSelf

**Tell** 异步发往目标，不等待、不保证对方一定处理；目标不存在或已终止时进入[死信](/docs/basics/death-letter)。

```go
ctx.Tell(recipientRef, myMessage)
```

**TellSelf** 向自身投递，等价于 `Tell(ctx.Ref(), message)`，由框架优化直接入队，用于本处理完成后触发下一阶段或拆成多步消息。

```go
ctx.TellSelf(nextPhaseMessage)
```

## Ask 与 Reply

<Callout type="tip" title="与 Tell 的区别">
**Ask** 需要回复时使用：发请求并返回 `Future`，用 `Result()` 等待回复或超时；**Tell** 则发后即忘、不阻塞。
</Callout>

**Ask** 发请求并返回 **`vivid.Future[Message]`**，用 **Result()** 取回复或超时/错误。接收方在 `OnReceive` 里调用 **Reply(response)** 回复；`ctx.Sender()` 为 nil 时 Reply 被忽略。超时可由 [Actor 配置](/docs/config/actor-config) 或 [Actor System 配置](/docs/config/actor-system-config) 修改，默认 `vivid.DefaultAskTimeout`。

```go
future := ctx.Ask(recipientRef, request, 5*time.Second)
result, err := future.Result()
// 接收方: ctx.Reply(responseMessage)
```

### Future

Ask 返回的 **Future[Message]** 是异步请求-响应的结果占位，主要方法：

| 方法 | 说明 |
|------|------|
| **Result() (T, error)** | 阻塞直到完成或超时/异常，返回结果与错误 |
| **Wait() error** | 阻塞直到结束，只返回错误，不返回结果 |
| **Close(err error)** | 主动关闭 Future，标记为完成或失败 |

---

## 相关专题

- **[结果转发（PipeTo）](/docs/basics/pipe-to)**：将 Ask 结果转发给指定 Actor。
- **[死信](/docs/basics/death-letter)**：无法投递时的处理与 DeathLetterEvent 订阅。
- **[托管异步任务（Entrust）](/docs/basics/entrust)**：在 Actor 内托管异步任务并返回 Future。
- **[消息暂存（Stash）](/docs/basics/stash)**：消息暂存与恢复。
- **[调度器](/docs/basics/scheduler)**、**[事件流](/docs/basics/event-stream)**：定时与事件订阅。
- **[远程通讯](/docs/config/remoting)**：跨节点消息投递。
- **[可达性检测（Ping）](/docs/config/ping)**：系统级 Ping/Pong 与 RTT。
- Ask 超时等见 [Actor 配置](/docs/config/actor-config)、[Actor System 配置](/docs/config/actor-system-config)。
